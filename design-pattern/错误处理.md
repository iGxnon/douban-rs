## 错误处理

在用 go 写 gRPC 时，我就在想，如果请求出错了，那是应该把错误设计成各个错误码定义到 rpc 返回到 message 中，还是使用 gRPC 预设好的一些错误中？从设计角度上来说，我应该使用 gRPC 预设好的一些错误，不然 gRPC 设计这个干什么？**而且自己定义一套错误码也挺麻烦，将其在开发中普及开也很费力**。但事实上，我经常会往 message 里加错误相关的字段，象征性地添加一个 code，从不使用 gRPC 中设定好的错误码，究其原因还是因为 gRPC 中预设的错误代码太广泛了，无法精准定位某个错误，或许是无法和其他服务的错误处理保持一致，又或者是不想解析 rpc 调用时返回的错误，但这样做，真的好么？

1. 我们是否需要自定义的错误码？

   上网冲浪了一会，总结了一下自定义的错误码的好处：

    - 可以快速定位错误的类型、发生的位置
    - 方便在海量日志中检索
    - 更好的信息压缩率，更适合传输
    - 更方便进行差异化提供错误信息：不同的语种，语言风格
    - ...

   然后是坏处：

    - 增加大量维护成本
    - 无法获得错误发生时上下文信息：如参数错误时到底是传了哪个值导致的错误
    - ...

   针对第二种坏处，可以再带上一个错误摘要的信息来解决，与此同时，第三条好处也就失效了

   乍一看，我们收获了3条好处，只有1条坏处，好耶！

   但是，仔细想想，这些好处，它真的只有自定义错误码才可以做到么？还有这些好处真的很重要么？

   虽然没有自定义错误码不能在程序中快速判断错误的类型，但是我们通常也不会基于错误码写太多逻辑，毕竟错误码是会不断增加的。最常见的就是判断一下是否是某种错误，该不该暴露错误信息等，这些功能完全可以通过返回中增加一些附加字段完成。**如果错误处理太多，反而应该关注系统设计是否有问题了**

   方便在日志中检索错误这一块，如果没有规范化的错误码确实不太好办，错误信息太难规范化了，错误种类千奇百怪，每一人都有自己写错误信息的口吻。但是我们真的需要自定义错误码来精准的定位所有相关的错误么？其实，只要一步一步来定位就好了，先确定是哪种错误大类，像 gRPC 中定义的十几种宽泛错误，这一下就能砍掉绝大多数无关的错误信息了，然后对于该错误大类检索其详细信息中的关键字，例如 `INVALID_ARGUMENT` 就检索 `username`，`password `什么的，就可以差不多定位到登陆注册接口的错误信息了。甚至还可以为这十几种错误规范它们的错误摘要，如 `INVALID_ARGUMENT` 规范成 `Request field {} is {}, expect {}` 这样的模版，而且，如果 log 有代码位置的信息的话，直接检索对应错误代码的位置就行，**所以这个需求并不重要**

   差异化错误提示，额外为错误添加一个本地化错误信息就好了，根据请求时用户的本地化信息来选择对应的错误信息，其实 gRPC 的 Status 已经提供了这种需求的解决方式

   反而为系统设计错误码，会带来巨大的维护成本，错误码的不规范设计也会造成非常大的弊端，重构成本极高，在错误码的设计没有压倒性优势的前提下，这个弊端已经是致命的了

   我在 `common::status::prompt` 中添加了方便构建所有错误的宏，它可以帮助我规范化所有错误的信息，更方便我在日志中查找

2. 到底哪里出错了？

   一个请求出错了，最常见的原因就是请求的参数不对，这种错误应该要在解析请求参数时以详细的提示引导来返回给调用方。

   还有一些服务内部错误，如写入数据库时发生的错误，请求其他服务发生的网络错误，这种的错误的概要应该编码成 `internal error` 来避免攻击方基于错误信息进行攻击

   还有一些来自第三方的错误，通常是一些编解码的库，如 json 编解码错误，它的原因就很复杂了，可能是解码请求方发送的参数错误了，也可能是编解码服务内部的一些数据错误了，这时候对其的处理就比较麻烦了，需要从上下文的信息中推理

3. 如何接入 Rust 的错误处理？

   首先 Rust 的错误处理非常优秀（至少比 go 的摆烂错误处理好，也比 try catch 简洁，通过在 Result 类型后面加个 ? 来进行错误的自动传播的语法糖也非常棒

   通常我们会为自己的 `crate` 创建一个属于自己的 Error 类型，但它在遇到第三方错误处理时就有点麻烦了，我可以通过实现 From trait 来完成 ? 时隐时转换第三方错误到自己的错误类型上，但是用 ? 一把嗦过后，这种错误的具体原因就无从得知了，以至于我在返回错误时不清楚是否可以(在公开API上)暴露错误的细节，无法确定这个错误该划分到哪个类别上

   **我目前的解决方案是放弃自定义错误类型**

   领域中所有的错误都返回 gRPC 中的 Status，第三方错误转换成 Status 时手动进行 `map_err` ，这样就不会对某些第三方错误产生歧义了。对于一些已经明确错误类型，敏感信息的第三方错误，例如 `redis::Error` ，这个错误一般都是服务内部错误，其错误信息不能公开，就可以为 Status 实现 `From<redis::Error>` trait 来省去 `map_err` 的过程（孤儿原则会阻止 impl，可以考虑生成一个新的类型包裹 Status）。
   
   缺点就是在错误处理上稍微有点麻烦，有一点退化到 go 的错误处理的风格上了。所以，某种程度上，go 的错误处理哲学在编写库代码时十分的难受，但在编写业务代码时，这种简单直接的错误处理方式更避免出现歧义。
   
4. 它算出错了么？

   前不久和朋友讨论了一个问题：

   考虑下面的函数

   ```go
   func check(something) (bool, error) {
     ...
   }
   ```
   
   返回的类型中 `(bool, error)`，前者 check 的结果，后者表示 check 中发生的 error
   
   但也可以写成这样
   
   ```go
   func check(something) error {
     ...
   }
   ```
   
   如果 error == nil 的话，就说明 check 后的结果是 true，因为 `(true, error != nil)` 的返回是没有意义的，代码中应不被允许。
   
   从函数签名的简洁角度上来讲，使用第二种方式会更好，但使用第二种方式，就已经在默认 **check 结果为 false 时，它属于错误**，但在第一个函数签名中，可以明确看出 check 结果为 false 时，它不属于错误。
   
   在不考虑 `(false, error == nil)` 和 `(false, error != nil)` 的区别时，当然可以使用第二种签名，这也意味着已经默认了 false 是 error 中的一种的设定，这在写库函数时，没有任何负担。但在写业务代码时，你就得考虑了：
   
   "决定结果为 false 的错误和 error 中其他错误对其采取的行为是否不同"，例如在认证 jwt 时，返回的错误可能是 `TokenExpired` ，也可能是 `CryptorError`，前者表示 token 失效了，后者表示加密时发生了错误(可能是密钥格式问题等等)。对前者错误采取措施应当是返回给调用方 `token is expired` 的提示，而对后者错误采取的措施应当是返回 `internal error` 并阻止泄漏错误的细节信息(可能和密钥相关)
   
   在 Rust 里，可以规定一个 `enum` 类型的 error 作为返回，并在 `map_err` 时使用 `match` 来区分，而在 Go 里，有点麻烦，需要尝试 cast 成可能的错误类型来判断。它们都有一个共同的特点，就是麻烦（
   
   而采用了第一种函数签名，结果可能会好一些，因为这种签名已经将 check 结果为 false 从 error 种脱离出来了，对于产生的 error，如果可以直接转换成 `internal error` 那就不需要区分其具体类型了。

